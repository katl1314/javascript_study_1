// 동기 처리와 비동기 처리
// 함수가 실행되면 실행 컨텍스트(콜 스택)에 함수 실행 컨텍스트가 생성된다.
// 함수가 종료되면 콜 스택(실행 컨텍스트)에서 해당 함수를 pop(삭제)한다.

/* const foo = () => {};
const bar = () => {};

foo();
bar(); */
// 실행 컨텍스트(콜 스택)
//
// 전역 실행 컨텍스트
// 전역 실행 컨텍스트 -> foo함수 실행 컨텍스트
// 전역 실행 컨텍스트
// 전역 실행 컨텍스트 -> bar함수 실행 컨텍스트
// 전역 실행 컨텍스트
//

// 함수가 실행되기 위해서는 실행 컨텍스트에 함수 실행 컨텍스트가 푸시되어야 함.
// 실행컨텍스트에 푸시되는 것은 함수 실행의 시작을 나타낸다.
// 실행 컨텍스트의 팝이 되는 것은 함수 실행의 종료를 나타낸다.
// 함수 실행은 실행 컨텍스트(콜 스택)에서 관리한다.
// 자바스크립트 엔진은 단 하나의 실행 컨텍스트를 갖는다. => 싱글 스레드 방식(한번에 하나의 타스크만 실행)

/**
 * 동기식으로 처리하기 위한 sleep함수
 * 현재 실행중인 태스크가 종료될때까지 대기(block)하는 방식 => 현재 처리하고 있는 타스크가 종료될때 까지 대기
 * @param {function} func 
 * @param {number} delay 
 */

function sleep(func, delay) {
    // Date.now() : 현재 시간을 millisecond으로 반환함.
    const delayUntil = Date.now() + delay;

    while(Date.now() <= delayUntil);
    // 일정 시간이 지난 후에 func함수가 호출된다.
    func.call(this);
}

const bar = () => {
    console.log('bar함수 실행');
}

const foo = () => {
    console.log('foo함수 실행');
}

sleep(foo, 3 * 1000); // sleep함수는 3초이상 실행된다.

bar();

/**
 * 위 예제를 setTimeout을 이용하여 구현해보자.
 * setTimeout을 사용하게 되면 대기하는 것이 아닌 bar함수가 먼저 실행이 되고 3초 이후에 foo함수가 실행된다.
 * 비동기 : 현재 실행중인 타스크가 종료될때 까지 대기하지 않고 다음 타스크를 먼저 처리하는 방식
 */
console.log("===================================");

setTimeout(foo, 3 * 1000);
bar();